use std::fs::File;
use std::io::BufWriter;
use std::path::PathBuf;

use forgedthoughts::prelude::*;

use clap::{arg, Command};

fn cli() -> Command {
    Command::new("ftc")
        .about("Forged Thoughts compiler. Compiles and renders or polygonizes '.ft' language files.")
        .author("Markus Moenig")
        .version("0.1.3")
        .subcommand_required(false)
        .arg_required_else_help(false)
        .allow_external_subcommands(true)
        .subcommand(
            Command::new("input")
                .about("The input '.ft' file. Set to 'main.ft' by default.")
                .arg(arg!(<FILE> "The input file."))
                .arg_required_else_help(true),
        )
        .subcommand(
            Command::new("render")
                .about("Renders the input to an PNG image. Used by default.")
                //.arg(arg!(<FILE> "The input file."))
                //.arg_required_else_help(false),
        )
        .subcommand(
            Command::new("polygonize")
                .about("Polygonize the input to an OBJ file.")
                // .arg(arg!(<VALUE> "The remote to clone"))
                // .arg_required_else_help(false),
        )
}

fn main() {
    let matches = cli().get_matches();

    let ft = FT::new();

    let mut file_name = "main.ft";
    let mut polygonize = false;

    match matches.subcommand() {
        Some(("input", sub_matches)) => {
            file_name = sub_matches.get_one::<String>("FILE").expect("required");
        },
        Some(("polygonize", _sub_matches)) => {
                //file_name = sub_matches.get_one::<String>("FILE").expect("required");
            polygonize = true;
        },
        _ => {
        }
    }

    let rc = ft.compile(PathBuf::new(), file_name.into());

    if rc.is_ok() {
        if let Some(mut ctx) = rc.ok() {

            if polygonize == true {

                // Polygonize and save to an OBJ file
                let obj = ft.polygonize(&mut ctx);
                _ = std::fs::write("main.obj", obj);

            } else {

                // Render and save to an PNG file

                let mut buffer = ColorBuffer::new(ctx.settings.width as usize, ctx.settings.height as usize);

                let is_path_tracer = ctx.settings.renderer.iterations > 1;

                for i in 0..ctx.settings.renderer.iterations {

                    if is_path_tracer {
                        println!("Rendering iteration {}", i + 1);
                    }

                    ft.render(&mut ctx, &mut buffer);

                    let out = buffer.to_u8_vec();

                    // Write it to file

                    let path = "main.png";
                    let file = File::create(path).unwrap();
                    let ref mut w = BufWriter::new(file);

                    let mut encoder = png::Encoder::new(w, ctx.settings.width as u32, ctx.settings.height as u32);
                    encoder.set_color(png::ColorType::Rgba);
                    encoder.set_depth(png::BitDepth::Eight);
                    // Adding text chunks to the header
                    encoder
                        .add_text_chunk(
                            "ForgedThughts".to_string(),
                            "This image was generated by ForgedThoughts.com".to_string(),
                        )
                        .unwrap();

                    let mut writer = encoder.write_header().unwrap();

                    writer.write_image_data(&out).unwrap();
                }
            }
        }
    } else
    if let Some(err) = rc.err() {
        println!("{}", err);
    }
}
